import requests
import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
import asyncio
import csv
import json
import os
from io import BytesIO
from telegram import Bot
import config1
import ta
from datetime import datetime, timezone

INTERVAL = '15m'
RENKO_CSV_FILE = "renko_bricks.csv"
ALERT_HISTORY_FILE = "alert_history.json"

# Fetch SELECTED_SYMBOLS dynamically from Binance Futures
url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
try:
    response = requests.get(url)
    response.raise_for_status()  # Check if the request was successful
    data = response.json()

    SELECTED_SYMBOLS = [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT' and s['status'] == 'TRADING'
    ]
except requests.exceptions.RequestException as e:
    print(f"Error fetching data from Binance Futures: {e}")
    SELECTED_SYMBOLS = []

# Initialize Binance client
binance = ccxt.binance({
    'apiKey': config1.API_KEY,
    'secret': config1.API_SECRET,
})

# Load alert history
try:
    with open(ALERT_HISTORY_FILE, "r") as file:
        last_alert_messages = json.load(file)
except (FileNotFoundError, json.JSONDecodeError):
    last_alert_messages = {}

def save_alert_history():
    with open(ALERT_HISTORY_FILE, "w") as file:
        json.dump(last_alert_messages, file, indent=4)

def get_historical_data(symbol, interval, limit=1000):
    ohlcv = binance.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    return df

def calculate_ema(df, period):
    return ta.trend.EMAIndicator(df['Close'], window=period).ema_indicator()

def detect_ema_crossover(renko_df):
    if len(renko_df) < 3:
        return None

    ema_short_prev, ema_long_prev = renko_df['ema_short'].iloc[-2], renko_df['ema_long'].iloc[-2]
    ema_short_curr, ema_long_curr = renko_df['ema_short'].iloc[-1], renko_df['ema_long'].iloc[-1]

    if ema_short_curr > ema_long_curr:
        return "Bullish Crossover"
    elif ema_short_curr < ema_long_curr:
        return "Bearish Crossunder"
    return None

def plot_renko_chart(df, symbol):
    renko_df = df[-120:]
    renko_df['ema_short'] = calculate_ema(renko_df, 2)
    renko_df['ema_long'] = calculate_ema(renko_df, 26)
    
    crossover_signal = detect_ema_crossover(renko_df)
    if not crossover_signal:
        return None, None, None

    mc = mpf.make_marketcolors(up='#2fc71e', down='#ed2f1a', inherit=True)
    s = mpf.make_mpf_style(base_mpl_style=['bmh', 'dark_background'], marketcolors=mc, y_on_right=True)

    fig, ax = mpf.plot(
        renko_df, figratio=(10, 6), type="candle", style=s, tight_layout=True,
        datetime_format='%H:%M', ylabel="Price ($)",
        addplot=[
            mpf.make_addplot(renko_df['ema_short'], color='cyan', width=1.5, linestyle='-'),
            mpf.make_addplot(renko_df['ema_long'], color='magenta', width=1.5, linestyle='-'),
        ], returnfig=True
    )
    
    ax[0].set_title(f"{symbol} - Renko Chart", fontsize=18)
    
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)

    close_price = renko_df['Close'].iloc[-1]
    return buf, crossover_signal, close_price

# Function to send payload to 3Commas
async def send_3commas_payload(symbol, action, close_price, timestamp):
    payloads = [
        {
            "secret": config1.SECRET_1,
            "max_lag": "300",
            "timestamp": timestamp,
            "trigger_price": str(close_price),
            "tv_exchange": "bitget",
            "tv_instrument": symbol + '.P',
            "action": action,
            "bot_uuid": config1.BOT_UUID_1,
        },
        {
            "secret": config1.SECRET_2,
            "max_lag": "300",
            "timestamp": timestamp,
            "trigger_price": str(close_price),
            "tv_exchange": "bitget",
            "tv_instrument": symbol + '.P',
            "action": action,
            "bot_uuid": config1.BOT_UUID_2,
        }
    ]

    for payload in payloads:
        try:
            response = requests.post(config1.THREECOMMAS_WEBHOOK_URL, json=payload)
            response.raise_for_status()
            print(f"3Commas alert sent for {symbol} - {action}: {response.text}")
        except requests.exceptions.RequestException as e:
            print(f"Error sending alert to 3Commas for {symbol}: {e}")

async def main(tg_bot):
    while True:
        for symbol in SELECTED_SYMBOLS:
            try:
                df = get_historical_data(symbol, INTERVAL)
                image_buffer, crossover_signal, close_price = plot_renko_chart(df, symbol)

                if image_buffer and crossover_signal:
                    action = "enter_long" if crossover_signal == "Bullish Crossover" else "enter_short"
                    timestamp = int(datetime.now(timezone.utc).timestamp())

                    # Prevent duplicate alerts
                    last_message = last_alert_messages.get(symbol)
                    current_message = f"{symbol}: {crossover_signal} at {close_price}"

                    if last_message != current_message:
                        last_alert_messages[symbol] = current_message
                        save_alert_history()

                        await tg_bot.send_photo(
                            chat_id=config1.CHAT_ID, 
                            photo=image_buffer, 
                            caption=f"#{symbol}: {crossover_signal} at {close_price}"
                        )
                        await send_3commas_payload(symbol, action, close_price, timestamp)

            except Exception as e:
                print(f"Error processing {symbol}: {e}")

        await asyncio.sleep(15)

if __name__ == "__main__":
    tg_bot = Bot(token=config1.TELEGRAM_TOKEN)
    asyncio.run(main(tg_bot))
