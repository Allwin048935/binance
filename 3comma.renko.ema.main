import requests
import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
import asyncio
import csv
import json
import os
from io import BytesIO
from telegram import Bot
import config
import ta
from datetime import datetime

INTERVAL = '1m'
RENKO_CSV_FILE = "renko_bricks.csv"
EMA_CSV_FILE = "ema_values.csv"
ALERT_HISTORY_FILE = "alert_history.json"

# Fetch selected symbols dynamically from Binance
url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
try:
    response = requests.get(url)
    response.raise_for_status()
    data = response.json()
    SELECTED_SYMBOLS = [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT' and s['status'] == 'TRADING'
    ]
except requests.exceptions.RequestException as e:
    print(f"Error fetching symbols: {e}")
    SELECTED_SYMBOLS = []

# Initialize Binance client
binance = ccxt.binance({
    'apiKey': config.API_KEY,
    'secret': config.API_SECRET,
})

# Load alert history
def load_json_file(file_path):
    try:
        with open(file_path, "r") as file:
            return json.load(file)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

last_alert_messages = load_json_file(ALERT_HISTORY_FILE)

def save_json_file(file_path, data):
    with open(file_path, "w") as file:
        json.dump(data, file, indent=4)

def get_historical_data(symbol, interval, limit=3000):
    ohlcv = binance.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    return df

def load_renko_history():
    if not os.path.exists(RENKO_CSV_FILE):
        return {}
    return pd.read_csv(RENKO_CSV_FILE).groupby('Symbol').apply(lambda x: x.to_dict('records'), include_groups=False).to_dict()

def save_renko_history(renko_history):
    df = pd.concat([pd.DataFrame(bricks).assign(Symbol=symbol) for symbol, bricks in renko_history.items()])
    df.to_csv(RENKO_CSV_FILE, index=False)

def load_ema_history():
    if not os.path.exists(EMA_CSV_FILE):
        return {}
    return pd.read_csv(EMA_CSV_FILE).groupby('Symbol').apply(lambda x: x.to_dict('records'), include_groups=False).to_dict()

def save_ema_history(ema_history):
    df = pd.concat([pd.DataFrame(values).assign(Symbol=symbol) for symbol, values in ema_history.items()])
    df.to_csv(EMA_CSV_FILE, index=False)

def calculate_ema(df, period):
    return ta.trend.EMAIndicator(df['Close'], window=period).ema_indicator()

def convert_to_renko(symbol, df, brick_size_percent=0.5):
    renko_history = load_renko_history()
    ref_close = df['Close'].iloc[-2]
    brick_size = ref_close * (brick_size_percent / 100)
    last_brick_close = renko_history.get(symbol, [{'Close': ref_close}])[-1]['Close']
    new_renko_data = renko_history.get(symbol, [])
    for close in df['Close']:
        diff = close - last_brick_close
        if abs(diff) >= brick_size:
            num_bricks = int(abs(diff) // brick_size)
            direction = 1 if diff > 0 else -1
            for _ in range(num_bricks):
                new_brick_close = last_brick_close + (direction * brick_size)
                new_renko_data.append({'Open': last_brick_close, 'Close': new_brick_close})
                last_brick_close = new_brick_close
    renko_history[symbol] = new_renko_data[-5000:]
    save_renko_history(renko_history)
    renko_df = pd.DataFrame(new_renko_data)
    renko_df.index = pd.RangeIndex(start=0, stop=len(renko_df), step=1)  # Ensure the index is compatible
    return renko_df

def detect_ema_crossover(renko_df):
    if len(renko_df) < 2:
        return None
    if renko_df['ema_short'].iloc[-1] > renko_df['ema_long'].iloc[-1]:
        return "Bullish Crossover"
    elif renko_df['ema_short'].iloc[-1] < renko_df['ema_long'].iloc[-1]:
        return "Bearish Crossunder"
    return None

def plot_renko_chart(df, symbol):
    renko_df = convert_to_renko(symbol, df)
    if renko_df.empty:
        return None, None
    ema_history = load_ema_history()
    renko_df['ema_short'] = calculate_ema(renko_df, 2)
    renko_df['ema_long'] = calculate_ema(renko_df, 26)
    ema_history[symbol] = renko_df[['Close', 'ema_short', 'ema_long']].to_dict('records')
    save_ema_history(ema_history)
    crossover_signal = detect_ema_crossover(renko_df)
    if not crossover_signal:
        return None, None
    fig, ax = mpf.plot(renko_df, type='candle', style='charles', addplot=[
        mpf.make_addplot(renko_df['ema_short'], color='cyan'),
        mpf.make_addplot(renko_df['ema_long'], color='magenta')
    ], returnfig=True)
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    return buf, crossover_signal

async def main(tg_bot):
    while True:
        for symbol in SELECTED_SYMBOLS:
            try:
                df = get_historical_data(symbol, INTERVAL)
                image_buffer, crossover_signal = plot_renko_chart(df, symbol)
                if image_buffer and crossover_signal:
                    await tg_bot.send_photo(chat_id=config.CHAT_ID, photo=image_buffer, caption=f"#{symbol}: {crossover_signal}")
            except Exception as e:
                print(f"Error processing {symbol}: {e}")
        await asyncio.sleep(30)

if __name__ == "__main__":
    tg_bot = Bot(token=config.TELEGRAM_TOKEN)
    asyncio.run(main(tg_bot))
