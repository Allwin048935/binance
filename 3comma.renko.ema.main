import requests
import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
import asyncio
import csv
import json
import os
from io import BytesIO
from telegram import Bot
import config1
import ta
from datetime import datetime, timezone

INTERVAL = '1m'
RENKO_CSV_FILE = "renko_bricks.csv"
ALERT_HISTORY_FILE = "alert_history.json"

# Fetch selected symbols dynamically from Binance
url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
try:
    response = requests.get(url)
    response.raise_for_status()
    data = response.json()
    SELECTED_SYMBOLS = [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT' and s['status'] == 'TRADING'
    ]
except requests.exceptions.RequestException as e:
    print(f"Error fetching symbols: {e}")
    SELECTED_SYMBOLS = []

# Initialize Binance client
binance = ccxt.binance({
    'apiKey': config1.API_KEY,
    'secret': config1.API_SECRET,
})

# Load alert history
try:
    with open(ALERT_HISTORY_FILE, "r") as file:
        last_alert_messages = json.load(file)
except (FileNotFoundError, json.JSONDecodeError):
    last_alert_messages = {}

def save_alert_history():
    with open(ALERT_HISTORY_FILE, "w") as file:
        json.dump(last_alert_messages, file, indent=4)

def get_historical_data(symbol, interval, limit=3000):
    ohlcv = binance.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.rename(columns={'open': 'Open', 'high': 'High', 'low': 'Low', 'close': 'Close', 'volume': 'Volume'}, inplace=True)
    return df

def convert_to_renko(symbol, df, brick_size_percent=0.5):
    if len(df) < 3:
        return pd.DataFrame()
    
    brick_size = df['Close'].iloc[-2] * (brick_size_percent / 100)
    renko_bricks = []
    last_close = df['Close'].iloc[-2]

    for close in df['Close']:
        diff = close - last_close
        if abs(diff) >= brick_size:
            num_bricks = int(abs(diff) // brick_size)
            direction = 1 if diff > 0 else -1
            for _ in range(num_bricks):
                new_brick = last_close + direction * brick_size
                renko_bricks.append({'Open': last_close, 'Close': new_brick})
                last_close = new_brick

    renko_df = pd.DataFrame(renko_bricks)
    if not renko_df.empty:
        renko_df.index = pd.date_range(start=df.index[0], periods=len(renko_df), freq='min')
    
    return renko_df

def calculate_ema(df, period):
    """ Fix: Remove incorrect groupby and ensure index consistency """
    if df.empty or 'Close' not in df:
        return pd.Series(dtype='float64')
    
    ema = ta.trend.EMAIndicator(close=df['Close'], window=period).ema_indicator()
    ema.index = df.index  # Ensure EMA index matches DataFrame index
    return ema

def detect_ema_crossover(renko_df):
    if len(renko_df) < 2:
        return None

    if renko_df['ema_short'].iloc[-1] > renko_df['ema_long'].iloc[-1]:
        return "Bullish Crossover"
    elif renko_df['ema_short'].iloc[-1] < renko_df['ema_long'].iloc[-1]:
        return "Bearish Crossunder"
    return None

async def main(tg_bot):
    while True:
        for symbol in SELECTED_SYMBOLS:
            try:
                df = get_historical_data(symbol, INTERVAL)
                renko_df = convert_to_renko(symbol, df)

                if not renko_df.empty:
                    renko_df['ema_short'] = calculate_ema(renko_df, 2)
                    renko_df['ema_long'] = calculate_ema(renko_df, 26)
                    
                    crossover_signal = detect_ema_crossover(renko_df)
                    if crossover_signal:
                        await tg_bot.send_message(chat_id=config1.CHAT_ID, text=f"#{symbol}: {crossover_signal}")
            except Exception as e:
                print(f"Error processing {symbol}: {e}")
        await asyncio.sleep(30)

if __name__ == "__main__":
    tg_bot = Bot(token=config1.TELEGRAM_TOKEN)
    asyncio.run(main(tg_bot))
