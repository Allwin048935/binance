import requests
import ccxt
import pandas as pd
import asyncio
import nest_asyncio
import config1  # Import the config module
import ta  # Import ta library

# Define time intervals
short_interval = '5m'  # 5-minute interval
long_interval = '4h'   # 4-hour interval

# Fetch SELECTED_SYMBOLS dynamically from Binance Futures
url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
try:
    response = requests.get(url)
    response.raise_for_status()  # Check if the request was successful
    data = response.json()

    SELECTED_SYMBOLS = [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT' and s['status'] == 'TRADING'
    ]
except requests.exceptions.RequestException as e:
    print(f"Error fetching data from Binance Futures: {e}")
    SELECTED_SYMBOLS = []

# Initialize Binance client
binance = ccxt.binance({
    'apiKey': config1.API_KEY,
    'secret': config1.API_SECRET,
})

# Dictionary to track the last alert message sent for each symbol
last_alert_messages = {}

# Function to get historical candlestick data
def get_historical_data(symbol, interval, limit=100):
    ohlcv = binance.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)

    # Rename columns to match mplfinance format
    df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    return df

# Function to calculate EMA using ta library
def calculate_ema(df, period):
    return ta.trend.EMAIndicator(df['Close'], window=period).ema_indicator()

# Function to check EMA crossover
def check_ema_cross(short_df, long_df):
    short_ema = calculate_ema(short_df, period=9)  # 5m EMA (9)
    long_ema = calculate_ema(long_df, period=30)   # 4h EMA (30)

    # Use the latest two values to check for crossover
    cross_over = short_ema.iloc[-2] > long_ema.iloc[-2] and short_ema.iloc[-3] <= long_ema.iloc[-3]
    cross_under = short_ema.iloc[-2] < long_ema.iloc[-2] and short_ema.iloc[-3] >= long_ema.iloc[-3]

    return cross_over, cross_under

# Function to send payload to 3Commas
async def send_3commas_payload(symbol, action, close_price, timestamp):
    payloads = [
        {
            "secret": config1.SECRET_1,
            "max_lag": "300",
            "timestamp": timestamp,
            "trigger_price": str(close_price),
            "tv_exchange": "bitget",
            "tv_instrument": symbol + '.P',
            "action": action,
            "bot_uuid": config1.BOT_UUID_1,
        },
        {
            "secret": config1.SECRET_2,
            "max_lag": "300",
            "timestamp": timestamp,
            "trigger_price": str(close_price),
            "tv_exchange": "bitget",
            "tv_instrument": symbol + '.P',
            "action": action,
            "bot_uuid": config1.BOT_UUID_2,
        }
    ]

    for payload in payloads:
        try:
            response = requests.post('https://api.3commas.io/signal_bots/webhooks', json=payload)
            response.raise_for_status()
            print(f"Payload sent for {symbol} with action {action}")
        except requests.exceptions.RequestException as e:
            print(f"Error sending payload for {symbol}: {e}")

# Main function
async def main():
    while True:
        for symbol in SELECTED_SYMBOLS:
            try:
                # Fetch historical data for both time intervals
                short_data = get_historical_data(symbol, short_interval)
                long_data = get_historical_data(symbol, long_interval)

                # Check EMA crossovers
                ema_cross_over, ema_cross_under = check_ema_cross(short_data, long_data)
                close_price = short_data['Close'].iloc[-1]
                timestamp = int(short_data.index[-1].timestamp())

                # EMA cross events
                if ema_cross_over:
                    action = 'enter_long'
                elif ema_cross_under:
                    action = 'enter_short'
                else:
                    action = None

                if action:
                    # Check if the last message is the same as the current one
                    last_message = last_alert_messages.get(symbol)
                    current_message = f"{symbol}:{action}"

                    if last_message != current_message:
                        await send_3commas_payload(symbol, action, close_price, timestamp)
                        last_alert_messages[symbol] = current_message
                    else:
                        print(f"Skipping duplicate message for {symbol}: {action}")

            except Exception as e:
                print(f"Error processing {symbol}: {e}")

        await asyncio.sleep(300)  # Check every 5 minutes

# Use nest_asyncio for Jupyter compatibility
nest_asyncio.apply()

# Create and run the event loop
asyncio.run(main())
