import ccxt
import pandas as pd
import ta  # Import ta library
import asyncio
from datetime import datetime

# Initialize Binance Futures Testnet client
exchange = ccxt.binance({
    'apiKey': '7cd27ce6b7dfb9f453e87aaf006f2158d7ad142314ed746659a5a1cd788f5ad8',
    'secret': '3326cb1c97da66a451128e8745c7dcba74edfb2499a6f6424021cb7f322b03a1',
    'options': {
        'defaultType': 'future',  # Set default type to futures
    },
    'enableRateLimit': True,  # Enable rate limiting
})

# Switch to Binance Futures Testnet (sandbox mode)
exchange.set_sandbox_mode(True)

# Function to get historical candlestick data
def get_historical_data(symbol, interval, limit=100):
    ohlcv = exchange.fetch_ohlcv(symbol, interval, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Function to convert candlestick data to Renko bricks
def convert_to_renko(df, brick_size_percent=2.5):
    if len(df) < 3:
        return pd.DataFrame()  # Not enough data

    ref_close = df['close'].iloc[-2]  # Use the close price of the second-to-last candle
    brick_size = ref_close * (brick_size_percent / 100)  # Calculate brick size
    renko_data = []
    last_brick_close = ref_close  # Start from the reference close price

    for i in range(1, len(df)):
        close = df['close'].iloc[i]
        diff = close - last_brick_close

        if abs(diff) >= brick_size:
            num_bricks = int(abs(diff) // brick_size)
            direction = 1 if diff > 0 else -1

            for _ in range(num_bricks):
                new_brick_close = last_brick_close + (direction * brick_size)
                renko_data.append({
                    'open': last_brick_close,
                    'high': max(last_brick_close, new_brick_close),
                    'low': min(last_brick_close, new_brick_close),
                    'close': new_brick_close
                })
                last_brick_close = new_brick_close

    renko_df = pd.DataFrame(renko_data)
    if not renko_df.empty:
        renko_df.index = pd.date_range(start=df.index[0], periods=len(renko_df), freq='min')

    return renko_df

# Function to calculate EMA
def calculate_ema(df, period):
    return ta.trend.EMAIndicator(df['close'], window=period).ema_indicator()

# Function to calculate MACD histogram
def calculate_macd_histogram(df):
    macd = ta.trend.MACD(df['close'])
    df['macd'] = macd.macd()
    df['signal'] = macd.macd_signal()
    df['histogram'] = macd.macd_diff()

# Function to place order on Binance Futures Testnet
async def place_order(symbol, side, quantity):
    try:
        order = exchange.create_market_order(symbol, side, quantity)
        print(f"Order placed: {order}")
    except Exception as e:
        print(f"Error placing order: {e}")

# Main function
async def main():
    symbol = 'XRP/USDT'  # Example symbol
    interval = '5m'  # 15-minute candlesticks
    brick_size_percent = 0.25# Renko brick size (2.5% of price)

    while True:
        try:
            # Fetch historical data
            df = get_historical_data(symbol, interval)

            # Convert to Renko bricks
            renko_df = convert_to_renko(df, brick_size_percent)
            if renko_df.empty:
                print("Not enough data to generate Renko bricks.")
                await asyncio.sleep(300)
                continue

            # Calculate EMA and MACD histogram
            renko_df['ema_short'] = calculate_ema(renko_df, 5)
            renko_df['ema_long'] = calculate_ema(renko_df, 10)
            calculate_macd_histogram(renko_df)

            # Check for crossover or crossdown
            crossover = (
                renko_df['ema_short'].iloc[-2] > renko_df['ema_long'].iloc[-2]
            )
            crossdown = (
                renko_df['ema_short'].iloc[-2] < renko_df['ema_long'].iloc[-2]
            )

            # Fetch current price to calculate quantity
            ticker = exchange.fetch_ticker(symbol)
            current_price = ticker['last']
            quantity = 100 / current_price  # Fixed $15 USD value

            # Place orders based on conditions
            if crossover:
                print("Crossover detected! Placing buy order...")
                await place_order(symbol, 'buy', quantity)

            elif crossdown:
                print("Crossdown detected! Placing sell order...")
                await place_order(symbol, 'sell', quantity)

        except Exception as e:
            print(f"Error: {e}")

        await asyncio.sleep(60)  # Run every 5 minutes

# Run the main function
asyncio.run(main())
